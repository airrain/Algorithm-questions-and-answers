"""
在一条环形的路上有N个加油站，每个加油站里有gas[i]的汽油，从第i个加油站到第i+1个加油站需要花费cost[i]的汽油。假设汽车的油箱可以装无数的汽油，判断一辆没有油的汽车是否可以从其中的某一个加油站出发并行驶一圈后返回该加油站。如果可以的话，返回起始加油站的下标，否则返回-1。

注意点：

    如果有答案的话，答案是唯一的
    不用考虑逆向行驶

例子:

输入: gas = [5, 1, 2, 3, 4], cost = [4, 4, 1, 5, 1]

输出: 4
解题思路

选择从一个加油站出发，如果车要能够到达下一个加油站，就需要这个加油站的gas>cost。不妨设c[i] = gas[i] - cost[i]，c[i]表示的是从某一加油站得到的汽油减去到达下一个加油站需要耗费的汽油后剩余的汽油数目，对c求和得到的是从出发开始到当前加油站剩余的汽油数目，如果这个这个和为负，说明当前这种行驶方案无法到达当前的加油站。也就是说要使车能够不断的向前行进，就要保证途中对c的求和始终大于0。

如果cost的和大于gas的和，显然汽车是无法成功走完一圈的，下面证明如果cost的和小于等于gas的和，必然存在一种方案能够让汽车走完一圈。

现在有c[0]+c[1]+...+c[n-2]+c[n-1]>=0，我们对c的前i项求和，假设当i=j时，这个和是所有和中最小的，也就是说：

c[0]+c[1]+...+c[j-1]<=c[0]+c[1]+...c[j]
c[0]+c[1]+...+c[j-1]<=c[0]+c[1]+...c[j]+c[j+1]
...
c[0]+c[1]+...+c[j-1]<=c[0]+c[1]+...c[j]+c[j+1]+...+c[n-1]

也就是说：

c[j]>=0
c[j]+c[j+1]>=0
...
c[j]+c[j+1]+...+c[n-1]>=0

同时，因为前j项的求和是最小的，还能得到下面的不等式：

c[0]+c[1]+...+c[j-1]<=c[0]+c[1]+...+c[j-2]
c[0]+c[1]+...+c[j-1]<=c[0]+c[1]+...+c[j-3]
...
c[0]+c[1]+...+c[j-1]<=c[0]

转换可以得到：

c[j-1]<=0
c[j-2]+c[j-1]<=0
...
c[1]+c[1]+...+c[j-1]<=0

再组合最初始的条件c[0]+c[1]+...+c[n-2]+c[n-1]>=0，我们可以得到：

c[j]+c[j+1]+...+c[n-1]+c[0]+c[1]+...+c[j-2]>=0
c[j]+c[j+1]+...+c[n-1]+c[0]+c[1]+...+c[j-3]>=0
c[j]+c[j+1]+...+c[n-1]+c[0]>=0

至此我们可以看出，如果从j出发的话，对c的求和始终都满足大于等于零的要求，也就是说j是我们选择出发的加油站。
"""
class Solution(object):
	def canCompleteCircuit(self,gas,cost):
		if sum(gas) < sum(cost):
			return -1
		min_sum,min_index,total = 0,0,0
		for i in range(len(gas)):
			total += gas[i] - cost[i]
			if min_sum > tatal:
				min_sum,min_index = tatal,i + 1
			return -1 if total < 0 else min_index

if __name__ == "__main__":
	Solution().canCompleteCircuit([5],[4])
